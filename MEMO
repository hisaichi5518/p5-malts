## Maltsを開発する時に注意する点

* フレームワークでの実装は極力少なくし、モジュールがある場合はそれを使用する
* Maltsの特徴に反する（遅くなる・分かりにくくなる）モジュールは使用しない
* テスト・ドキュメント・コード・Changesを同時にコミットする。
* なぜそのコードを書くのか考えてから書く
* 使い方が間違ってる場合は、警告ではなくエラーを出す。
* （設定ファイルをロードしようとしているのに、ファイルがなかった場合はエラーなど）
* フレームワークが勝手に行う"よしなに"は死ね
* なぜそうするかを明確にする
* Malts, Malts::Styleにベストプラクティスを用意し、初心者にも分かりやすい使い方を定める

## Malts::Styleのドキュメントっぽいの

* Malts::Styleにはコーディング規約を含める。
* コーディング規約とは、設計・開発する時に注意する点・命名規則。
* Malts::Style::*を使えば、それによって決められた規則に従うだけなのでコードを書く事だけに集中出来る。
* Malts::Styleを使えば、設計や命名規則を考える必要がない感じ。

## Maltsを使う時の前提

* フレークワークのコードは結局読む事になる。
* 速さは必要ではあるが、致命的に遅くなる場合を除いて分かりやすさを優先すべき。
* XSは非常に強力ではあるが、強力すぎるので採用には慎重であるべき。

## TODO

* Malts::Auth(?)
* セキュリティのあれこれ

## 設計メモ

* $cにロジックを生やすのはイケてない。ただ全部排除するのはイケてない。
$cはショートカットを生やすのはいい。=> $c->mobile_agent; など。
Web APIを叩くとかは全部モジュール + Modelでする。悩むならmodelに入れとけばいいんじゃないのか系。

こういうのはモデルでする。

    package MyApp::Model::Mobage;
    use WebService::Mobage;
    my $mobage = WebService::Mobage->new(...);

    sub get_mobage_friends {
        my ($user_id, $opts) = @_;
        $mobage->get_friends($user_id => $opts);
    }

* メソッドを生やすのはMalts::*
メソッドを生やすのはExporterを使う。=> 他のモジュールと同じような仕組みで提供する

* StyleでのModelはMalts::Style::Hoge::Model::* に入れる。

$cに保存するのは、アクセスする度に変更があり、かつキャッシュする必要があるもの。
request、sessionなど。

stateで保存するのは、起動すれば変更がないもの。
app_dirやroutesmなど。
